<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Ubuntu, Trebuchet MS;
			background-color: #c0c0c0;
			margin: 0px;
			overflow: hidden;
		}
		select {
			font-family: Ubuntu, Trebuchet MS;
		}
	</style>
</head>
<body>

	<script src="three.js"></script>
	<script src="OrbitControls.js"></script>
    <script src="particle.js"></script>
    <script src="sphereEmiter.js"></script>
    <script src="cubeEmitter.js"></script>
    
    <script type="x-shader/x-vertex" id="vertexshader">
        uniform float amplitude;
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        void main() {
            vColor = customColor;
            vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
            //gl_PointSize = size;
            gl_PointSize = size * ( 300.0 / length( mvPosition.xyz ) );
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform vec3 color;
        uniform sampler2D texture;
        varying vec3 vColor;
        void main() {
            gl_FragColor = vec4( color * vColor, 1.0 );
            gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );
        }
    </script>
	<script>
		var container;
		var camera, controls, scene, renderer;
        var parameters;
        var color, size;
        var h;
        var emiter;
        var numberOfParticles = 1000;
		var materials = [];
        var attributes;
        var uniforms;
        var lastTime;
        var timefactor = 0.00005;
        var particlesEmited;
        var shaderMaterial;
        var geometry;

		// start scene
		init();
		animate();

        function addParticles() {
            //scene.fog = new THREE.FogExp2( 0x000000, 0.001 );
            
            
            attributes = {
				size: {	type: 'f', value: [] },
				customColor: { type: 'c', value: [] }
			};
			uniforms = {
				amplitude: { type: "f", value: 1.0 },
				color:     { type: "c", value: new THREE.Color( 0xffffff ) },
				texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "textures/spark.png" ) },
			};
            
			shaderMaterial = new THREE.ShaderMaterial( {
				uniforms:       uniforms,
				attributes:     attributes,
				vertexShader:   document.getElementById( 'vertexshader' ).textContent,
				fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
				blending:       THREE.AdditiveBlending,
				depthTest:      false,
				transparent:    true
			});
            
            //emiter = $SE();
            emiter = $CE();

            
            particlesEmited = emiter.EmitParticles(numberOfParticles);
            
            geometry = new THREE.Geometry();
            
            for ( i = 0; i < particlesEmited.length; i ++ ) {
                var vertex = new THREE.Vector3();
                vertex = particlesEmited[i].m_Position;
                geometry.vertices.push( vertex );
            }

            particles = new THREE.PointCloud( geometry, shaderMaterial );
            
            
            var vertices = particles.geometry.vertices;
			var values_size = attributes.size.value;
			var values_color = attributes.customColor.value;
			for ( var v = 0; v < vertices.length; v++ ) {
				values_size[ v ] = particlesEmited[v].m_fsize;
				values_color[ v ] = new THREE.Color( 0xffaa00 );
				values_color[ v ].setHSL( 0.5 + 0.1 * ( v / vertices.length ), 1.0, 1.0 );
			}
			scene.add( particles );
        }
        function updateParticles() {
            scene.remove(particles);
            
            var curTime = Date.now() * timefactor;
            var deltaTime = curTime - lastTime;
            lastTime = curTime;
            
            geometry = new THREE.Geometry();
            
            for ( i = 0; i < particlesEmited.length; i ++ ) {
                if (particlesEmited[i].m_alive == 1.0) {
                    particlesEmited[i].update(deltaTime);
                    var vertex = new THREE.Vector3();
                    vertex = particlesEmited[i].m_Position;
                    geometry.vertices.push( vertex );
                }
            }

            particles = new THREE.PointCloud( geometry, shaderMaterial );
            
            
            var vertices = particles.geometry.vertices;
			var values_size = attributes.size.value;
			var values_color = attributes.customColor.value;
			for ( var v = 0; v < vertices.length; v++ ) {
                if (particlesEmited[v].m_alive == 1.0) {
                    values_size[ v ] = particlesEmited[v].m_fsize;
                    values_color[ v ] = new THREE.Color( 0xffaa00 );
                    values_color[ v ].setHSL( 0.5 + 0.1 * ( v / vertices.length ), 1.0, 1.0 );
                }
			}
			scene.add( particles );
            
        }
    
		function init() {
            //TIME
            lastTime = Date.now() * timefactor;
            
            //SCENE
            scene = new THREE.Scene();
            
            
			container = document.createElement( 'div' );
			document.body.appendChild( container );
			info = document.createElement( 'div' );
			info.style.position = 'absolute';
			info.style.top = '10px';
			info.style.width = '100%';
			info.style.textAlign = 'center';
			info.innerHTML = '';
			container.appendChild( info );
            // CAMERA
            var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
            var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
            camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
			//camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 10000 );
			//camera.position.z = 250;
            scene.add(camera);
            camera.position.set(0,150,400);
            camera.lookAt(scene.position);
            
            //RENDER
            renderer = new THREE.WebGLRenderer({antialias:true} );
            renderer.setSize( window.innerWidth, window.innerHeight );
            container.appendChild( renderer.domElement );
            controls = new THREE.OrbitControls( camera, renderer.domElement );
			
            
            //LIGHT
			var light = new THREE.PointLight( 0xffffff);
			light.position.set( 0, 250, 0 );
			scene.add( light );
			//SKYBOX
            var imagePrefix = "images/dawnmountain-";
	        var directions  = ["xpos", "xneg", "ypos", "yneg", "zpos", "zneg"];
            var imageSuffix = ".png";
            var skyGeometry = new THREE.CubeGeometry( 5000, 5000, 5000 );	
            var materialArray = [];
            for (var i = 0; i < 6; i++)
                materialArray.push( new THREE.MeshBasicMaterial({
                    map: THREE.ImageUtils.loadTexture( imagePrefix + directions[i] + imageSuffix ),
                    side: THREE.BackSide
                }));
            var skyMaterial = new THREE.MeshFaceMaterial( materialArray );
            var skyBox = new THREE.Mesh( skyGeometry, skyMaterial );
            scene.add( skyBox );
            
            addParticles();
			window.addEventListener( 'resize', onWindowResize, false );
		}
		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}
		function animate() {
			requestAnimationFrame( animate );
			controls.update();
            updateParticles();
			render();
		}
		function render() {
           
            var time = Date.now() * timefactor;
            /* 
            for ( i = 0; i < scene.children.length; i ++ ) {
                var object = scene.children[ i ];
                if ( object instanceof THREE.PointCloud ) {
                    object.rotation.y = time * ( i < 4 ? i + 1 : - ( i + 1 ) );
                }
            }
            */
            for( var i = 0; i < attributes.size.value.length; i++ ) {
				attributes.size.value[ i ] = 14 + 13 * Math.sin( 0.1 * i + time );
			}
			attributes.size.needsUpdate = true;
            
            
			renderer.render( scene, camera );
		}
	</script>

</body>
</html>